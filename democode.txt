# main.py
# Run:
#   source .venv/bin/activate
#   uvicorn main:app --reload --port 8000
#
# Env (.env):
#   DEEPGRAM_API_KEY=...
#   DEEPGRAM_MODEL=nova-3 (optional)
#   DEEPGRAM_LANG=en-IN (optional)
#
#   GEMINI_API_KEY=...
#   GEMINI_CLIENT_MODEL=gemini-2.5 (optional)
#   GEMINI_REPAIR_MODEL=gemini-2.5-flash-lite (optional)

from __future__ import annotations

import os
import uuid
import re
import json
import random
from typing import Dict, Any, List, Tuple, Optional

import requests
from dotenv import load_dotenv
from fastapi import FastAPI, Request, UploadFile, File
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from starlette.concurrency import run_in_threadpool

# Gemini SDK (Google Gen AI SDK)
from google import genai

load_dotenv()

# -----------------------
# App setup
# -----------------------
app = FastAPI()
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

SESSIONS: Dict[str, Dict[str, Any]] = {}

# -----------------------
# Deepgram STT settings
# -----------------------
DEEPGRAM_API_KEY = os.getenv("DEEPGRAM_API_KEY")
DEEPGRAM_LISTEN_URL = "https://api.deepgram.com/v1/listen"
DEEPGRAM_MODEL = os.getenv("DEEPGRAM_MODEL", "nova-3")
DEEPGRAM_LANG = os.getenv("DEEPGRAM_LANG", "en-IN")


def _deepgram_request(audio_bytes: bytes, content_type: str) -> Dict[str, Any]:
    if not DEEPGRAM_API_KEY:
        raise RuntimeError("DEEPGRAM_API_KEY not set")

    params = {
        "model": DEEPGRAM_MODEL,
        "language": DEEPGRAM_LANG,
        "smart_format": "true",
        "punctuate": "true",
    }
    headers = {
        "Authorization": f"Token {DEEPGRAM_API_KEY}",
        "Content-Type": content_type or "application/octet-stream",
    }

    r = requests.post(
        DEEPGRAM_LISTEN_URL,
        params=params,
        headers=headers,
        data=audio_bytes,
        timeout=60,
    )
    r.raise_for_status()
    return r.json()


def deepgram_extract_text(dg_json: Dict[str, Any]) -> Tuple[str, float]:
    try:
        channels = (dg_json.get("results", {}) or {}).get("channels", []) or []
        alternatives = (channels[0] or {}).get("alternatives", []) or []
        alt0 = alternatives[0] if alternatives else {}
        text = (alt0.get("transcript") or "").strip()
        conf = float(alt0.get("confidence") or 0.0)
        return text, conf
    except Exception:
        return "", 0.0


@app.post("/api/stt")
async def api_stt(audio: UploadFile = File(...)):
    """
    Upload an audio blob (MediaRecorder) and return transcript.
    """
    if not DEEPGRAM_API_KEY:
        return JSONResponse({"error": "DEEPGRAM_API_KEY not set"}, status_code=500)

    audio_bytes = await audio.read()
    if not audio_bytes:
        return JSONResponse({"error": "Empty audio upload"}, status_code=400)

    try:
        dg = await run_in_threadpool(
            _deepgram_request,
            audio_bytes,
            audio.content_type or "audio/webm",
        )
        text, conf = deepgram_extract_text(dg)
        return {"text": text, "confidence": conf}
    except Exception as e:
        return JSONResponse({"error": f"Deepgram STT failed: {e}"}, status_code=500)


# -----------------------
# Gemini (main + repair)
# -----------------------
GEMINI_CLIENT_MODEL = os.getenv("GEMINI_CLIENT_MODEL", "gemini-2.5")
GEMINI_REPAIR_MODEL = os.getenv("GEMINI_REPAIR_MODEL", "gemini-2.5-flash-lite")

# Client uses GEMINI_API_KEY automatically if set.
client = genai.Client()


def gemini_generate_text(
    prompt: str,
    model: str,
    temperature: float = 0.6,
    max_output_tokens: int = 220,
) -> str:
    resp = client.models.generate_content(
        model=model,
        contents=prompt,
        config={
            "temperature": temperature,
            "max_output_tokens": max_output_tokens,
        },
    )
    return (getattr(resp, "text", None) or "").strip()


def _safe_json(text: str) -> Dict[str, Any]:
    text = (text or "").strip()
    try:
        return json.loads(text)
    except Exception:
        pass
    start = text.find("{")
    end = text.rfind("}")
    if start != -1 and end != -1 and end > start:
        try:
            return json.loads(text[start : end + 1])
        except Exception:
            pass
    return {}


# -----------------------
# Scenarios
# -----------------------
SCENARIOS: Dict[str, Dict[str, Any]] = {
    "family_budget": {
        "name": "Family trip (budget-sensitive)",
        "persona": "Indian parent planning a family vacation",
        "tone": "friendly, slightly guarded",
        "hidden_slots": {
            "travellers": "2 adults + 2 kids",
            "month": "April",
            "priority": "safe + kid-friendly",
            "pace": "not too hectic",
            "departure_city": "Delhi",
            "duration": "5-7 nights",
            "budget": "₹60k–₹90k per adult (excluding shopping)",
        },
        "beats": {
            "price_objection": "I found a cheaper package online—why should I book with you?",
            "trust_objection": "How do I know this is reliable? What if something goes wrong during the trip?",
        },
        "max_turns": 8,
    },
    "honeymoon_premium": {
        "name": "Honeymoon (premium preferences)",
        "persona": "Newly married customer planning honeymoon",
        "tone": "excited but picky",
        "hidden_slots": {
            "travellers": "2 adults",
            "month": "March",
            "priority": "romantic + premium stay",
            "pace": "relaxed",
            "departure_city": "Mumbai",
            "duration": "6-8 nights",
            "budget": "₹2.0L–₹3.5L total",
        },
        "beats": {
            "price_objection": "This feels expensive—what makes it worth it?",
            "trust_objection": "Are these hotels actually good or just marketing photos?",
        },
        "max_turns": 9,
    },
}

# -----------------------
# Regex / heuristics
# -----------------------
TRAVEL_HINT = re.compile(
    r"\b(trip|travel|package|flight|hotel|itinerary|visa|booking|book|tour|holiday|vacation|honeymoon)\b",
    re.I,
)
OPEN_Q = re.compile(r"\b(what|how|why|which|when|where|could you|can you)\b", re.I)

PRICE_MENTION = re.compile(
    r"(₹\s?\d[\d,\.]*\s?(?:k|K|l|L|lac|lakh|lakhs|cr|crore|crores)?)"
    r"|(\b\d+(\.\d+)?\s?(?:k|K|l|L|lac|lakh|lakhs|cr|crore|crores)\b)"
    r"|(\bper person\b|\bpp\b|\bestimate\b|\bquote\b|\bapprox\b|\brough\b|\baround\b|\bstarts at\b|\bstarting at\b)",
    re.I,
)

ASK_DEST_RX = re.compile(
    r"\b(destination|where.*(go|travel)|where (are|r) you going|where do you want to go|"
    r"suggest (a )?(destination|place)|any place in mind|which place)\b",
    re.I,
)
ASK_BUDGET_RX = re.compile(r"\b(budget|price range|spend|cost|per person|pp|range|total budget)\b", re.I)
ASK_DATES_RX = re.compile(r"\b(when|date|dates|month|week|which week|travel when|timing|season)\b", re.I)
ASK_PAX_RX = re.compile(r"\b(how many|travell?ers|people|persons|adults|kids|children)\b", re.I)

# IMPORTANT FIX: remove "activities" from general prefs to avoid overlap/multi-misfires
ASK_PREFS_RX = re.compile(
    r"\b(preference|preferences|pace|relaxed|sightseeing|kid[-\s]?friendly|"
    r"luxury|premium|budget hotel)\b",
    re.I,
)

# IMPORTANT FIX: duration should NOT match "how many" by itself (collides with pax)
ASK_DURATION_RX = re.compile(
    r"\b(how\s+many\s+(nights?|days?)|how\s+long|duration|length\s+of\s+(stay|trip)|number\s+of\s+(nights?|days?))\b",
    re.I,
)

# Activities (autonomy + memory)
ASK_ACTIVITIES_RX = re.compile(
    r"\b(activities|things to do|do there|interests|adventure|water sports|scuba|snorkel|hiking|shopping|nightlife)\b",
    re.I,
)

# Soft prefs (hotel/room/food) — let Gemini answer and extractor remember
ASK_HOTEL_RX = re.compile(
    r"\b(hotel|stay|resort|property|category|star|3\s*star|4\s*star|5\s*star|boutique)\b",
    re.I,
)
ASK_ROOM_RX = re.compile(
    r"\b(room|rooms|suite|connecting|extra bed|twin|double|family room)\b",
    re.I,
)
ASK_FOOD_RX = re.compile(
    r"\b(food|meal|meals|breakfast|lunch|dinner|veg|vegetarian|non-veg|buffet|all[-\s]?inclusive)\b",
    re.I,
)

NEXT_STEP_RX = re.compile(r"\b(book|booking|pay|payment|send.*(whatsapp|email)|proposal|quote|hold|confirm)\b", re.I)
INCLUSIONS_RX = re.compile(r"\b(include|included|exclude|exclusions|inclusions|cancellation|refund|policy|terms)\b", re.I)
ABUSE_RX = re.compile(r"\b(kill yourself|kys|die|suicide|idiot|stupid|bitch|fuck you)\b", re.I)

STAGE_PAREN = re.compile(r"\([^)]*\)")
STAGE_BRACK = re.compile(r"\[[^\]]*\]")
STAGE_ASTER = re.compile(r"\*[^*]+\*")

MONTHS_RX = re.compile(
    r"\b(jan|january|feb|february|mar|march|apr|april|may|jun|june|jul|july|aug|august|sep|sept|september|oct|october|nov|november|dec|december)\b",
    re.I,
)
RUPEE_RX = re.compile(
    r"(₹\s?\d[\d,\.]*\s?(?:k|K|l|L|lac|lakh|lakhs|cr|crore|crores)?)|(\b\d+(\.\d+)?\s?(?:k|K|l|L|lac|lakh|lakhs|cr|crore|crores)\b)",
    re.I,
)

AGENTY_PHRASES_RX = re.compile(
    r"\b(i can assist|how can i assist|i recommend|i would recommend|i suggest|i would suggest|"
    r"we have (a few )?options|i can share|i can book|i can send the payment link|"
    r"i can help you with options|i can help you plan|i can help)\b",
    re.I,
)


def detect_agent_signals(text: str) -> Dict[str, bool]:
    t = text or ""
    asked_activities = bool(ASK_ACTIVITIES_RX.search(t))
    asked_hotel = bool(ASK_HOTEL_RX.search(t))
    asked_room = bool(ASK_ROOM_RX.search(t))
    asked_food = bool(ASK_FOOD_RX.search(t))
    asked_soft_prefs = asked_activities or asked_hotel or asked_room or asked_food

    return {
        "asked_destination": bool(ASK_DEST_RX.search(t)),
        "asked_budget": bool(ASK_BUDGET_RX.search(t)),
        "asked_dates": bool(ASK_DATES_RX.search(t)),
        "asked_travellers": bool(ASK_PAX_RX.search(t)),
        "asked_duration": bool(ASK_DURATION_RX.search(t)),
        "asked_activities": asked_activities,
        "asked_hotel": asked_hotel,
        "asked_room": asked_room,
        "asked_food": asked_food,
        "asked_soft_prefs": asked_soft_prefs,
        "asked_preferences": bool(ASK_PREFS_RX.search(t)),  # general prefs (pace/kid-friendly/etc.)
        "proposed_next_step": bool(NEXT_STEP_RX.search(t)),
        "mentioned_inclusions": bool(INCLUSIONS_RX.search(t)),
        "gave_price_estimate": bool(PRICE_MENTION.search(t)),
        "has_question_mark": ("?" in t),
    }


def heuristic_agent_style(text: str) -> Dict[str, bool]:
    words = (text or "").split()
    too_long = len(words) > 45
    pushy = bool(re.search(r"\bpay now|payment link|book today|confirm now\b", text or "", re.I))
    clear = not too_long
    polite = not bool(re.search(r"\b(whatever|listen|hurry)\b", text or "", re.I))
    return {"polite": polite, "pushy": pushy, "clear": clear, "too_long": too_long}


# -----------------------
# Customer output cleaning / guardrails
# -----------------------
def clean_client_reply(text: str) -> str:
    t = (text or "").strip()
    t = STAGE_PAREN.sub("", t)
    t = STAGE_BRACK.sub("", t)
    t = STAGE_ASTER.sub("", t)
    t = re.sub(r"^(tone|mood)\s*:\s*", "", t, flags=re.I).strip()
    t = t.strip().strip('"\u201c\u201d\u2018\u2019')
    t = re.sub(r"\s+([,.;!?])", r"\1", t)
    t = re.sub(r"([,.;!?]){2,}", r"\1", t)
    t = re.sub(r"\s+", " ", t).strip()
    t = re.sub(r"(\d)\.(\d)", r"\1 point \2", t)

    sentences = re.split(r"(?<=[.!?])\s+", t)
    sentences = [s.strip() for s in sentences if s.strip()]
    if len(sentences) > 2:
        t = " ".join(sentences[:2])

    if not t:
        t = "Hi—need to plan a trip; what details do you need from me?"
    return t


def strip_undisclosed_slot_literals(state: Dict[str, Any], text: str) -> str:
    t = text or ""
    slots = state.get("slots", {}) or {}
    disclosed = state.get("disclosed", {}) or {}

    for k, v in slots.items():
        if not isinstance(v, str) or not v.strip():
            continue
        if disclosed.get(k, False):
            continue
        t = re.sub(re.escape(v), "", t, flags=re.I)

    t = re.sub(r"\s+", " ", t).strip()
    return t


def strip_common_paraphrase_leaks(state: Dict[str, Any], text: str) -> str:
    t = text or ""
    disclosed = state.get("disclosed", {}) or {}

    if not disclosed.get("travellers", False):
        t = re.sub(r"\b(2|two)\s+adults?\b", "", t, flags=re.I)
        t = re.sub(r"\b(2|two)\s+(kids?|children)\b", "", t, flags=re.I)
        t = re.sub(r"\bfamily of (4|four)\b", "", t, flags=re.I)

    if not disclosed.get("month", False):
        t = MONTHS_RX.sub("", t)

    if not disclosed.get("budget", False):
        t = RUPEE_RX.sub("", t)

    if not disclosed.get("duration", False):
        t = re.sub(r"\b\d+\s*-\s*\d+\s*(nights?|days?)\b", "", t, flags=re.I)
        t = re.sub(r"\b\d+\s*(nights?|days?)\b", "", t, flags=re.I)

    t = re.sub(r"\s+", " ", t).strip()
    return t


def enforce_customer_guardrails(state: Dict[str, Any], reply: str, busy_allowed: bool) -> str:
    t = (reply or "").strip()
    t = AGENTY_PHRASES_RX.sub("", t).strip()
    t = re.sub(r"\s+", " ", t).strip()

    t = strip_undisclosed_slot_literals(state, t)
    t = strip_common_paraphrase_leaks(state, t)

    if not busy_allowed:
        t = re.sub(r"\b(i'?m|i am)\s+busy\b", "", t, flags=re.I)
        t = re.sub(
            r"\b(short on time|limited time|keep it brief|keep it quick|running out of time|tight schedule)\b",
            "",
            t,
            flags=re.I,
        )
        t = re.sub(r"\s+", " ", t).strip()

    t = re.sub(r"\s+([,.;!?])", r"\1", t)
    t = re.sub(r"\s+", " ", t).strip()

    if (not t) or AGENTY_PHRASES_RX.search(t):
        if busy_allowed:
            return "Hi—need to plan a trip, keep it quick please; what do you need from me?"
        return "Hi—need to plan a trip; what details do you need from me?"
    return t


def finalize_client_text(state: Dict[str, Any], text: str, busy_allowed: bool) -> str:
    t = clean_client_reply(text)
    t = enforce_customer_guardrails(state, t, busy_allowed=busy_allowed)
    t = re.sub(r"[()\[\]*]", "", t).strip()
    t = re.sub(r"\s{2,}", " ", t).strip()
    return t


def _norm(s: str) -> str:
    s = (s or "").lower()
    s = re.sub(r"[^a-z0-9₹ ]+", " ", s)
    s = re.sub(r"\s+", " ", s).strip()
    return s


def avoid_repeat(state: Dict[str, Any], reply: str, objective: str) -> str:
    transcript = state.get("_transcript_ref", []) or []
    last_client = ""
    for item in reversed(transcript):
        if item.get("speaker") == "client":
            last_client = item.get("text", "")
            break
    if not last_client:
        return reply

    if _norm(reply) == _norm(last_client) or _norm(reply) in _norm(last_client) or _norm(last_client) in _norm(reply):
        # objective-aware rephrase (prevents the "No fixed destination..." loop)
        slots = state.get("slots", {}) or {}
        if objective == "answer_duration":
            d = slots.get("duration") or "about a week"
            return f"Roughly {d}."
        if objective == "answer_budget":
            b = slots.get("budget") or "mid-range"
            return f"Budget-wise, around {b}."
        if objective == "answer_dates":
            m = slots.get("month") or "next month"
            return f"Timing is around {m}."
        if objective == "answer_travellers":
            p = slots.get("travellers") or "two adults"
            return f"It’ll be {p}."
        return "Okay—can you share 2–3 options and what the rough plan would look like?"
    return reply


# -----------------------
# Memory: soft preferences (autonomy + consistency)
# -----------------------
def get_soft_prefs(state: Dict[str, Any]) -> Dict[str, Any]:
    mem = state.setdefault("memory", {})
    prefs = mem.setdefault(
        "soft_prefs",
        {"theme": None, "activities": [], "hotel_style": None, "vibe": None, "food": None, "notes": []},
    )
    if not isinstance(prefs.get("activities"), list):
        prefs["activities"] = []
    if not isinstance(prefs.get("notes"), list):
        prefs["notes"] = []
    return prefs


def extract_soft_prefs(agent_text: str, client_reply: str, existing: Dict[str, Any]) -> Dict[str, Any]:
    prompt = f"""
Return ONLY strict JSON with schema:
{{
  "theme": string|null,
  "activities": [string],
  "hotel_style": string|null,
  "vibe": string|null,
  "food": string|null,
  "notes": [string]
}}

Rules:
- Only extract preferences that the CUSTOMER explicitly states or strongly implies.
- Do NOT invent or edit travellers/budget/month/dates/departure/duration/destination.
- If nothing new, return EXISTING_PREFS unchanged.

AGENT:
{agent_text}

CUSTOMER:
{client_reply}

EXISTING_PREFS:
{json.dumps(existing, ensure_ascii=False)}
""".strip()

    out = gemini_generate_text(
        prompt=prompt,
        model=GEMINI_REPAIR_MODEL,
        temperature=0.1,
        max_output_tokens=220,
    )
    data = _safe_json(out) or {}

    merged = dict(existing)

    for k in ["theme", "hotel_style", "vibe", "food"]:
        v = data.get(k, None)
        if isinstance(v, str) and v.strip():
            merged[k] = v.strip()

    if isinstance(data.get("activities"), list):
        add = [str(x).strip() for x in data["activities"] if str(x).strip()]
        merged["activities"] = sorted(list({*merged.get("activities", []), *add}))[:8]

    if isinstance(data.get("notes"), list):
        addn = [str(x).strip() for x in data["notes"] if str(x).strip()]
        merged["notes"] = (merged.get("notes", []) + addn)[:8]

    return merged


# -----------------------
# Disclosure control
# -----------------------
def disclose_if_asked(state: Dict[str, Any], sig: Dict[str, Any]) -> None:
    disclosed = state["disclosed"]

    if sig.get("asked_travellers"):
        disclosed["travellers"] = True
    if sig.get("asked_dates"):
        disclosed["month"] = True
        disclosed["dates"] = True
    if sig.get("asked_budget"):
        disclosed["budget"] = True
    if sig.get("asked_duration"):
        disclosed["duration"] = True
    if sig.get("asked_preferences"):
        disclosed["priority"] = True
        disclosed["pace"] = True
        disclosed["departure_city"] = True


def allowed_facts_for_prompt(state: Dict[str, Any]) -> Dict[str, Any]:
    slots = state["slots"]
    disclosed = state["disclosed"]
    allowed: Dict[str, Any] = {}
    for k, v in slots.items():
        if disclosed.get(k, False) and v is not None:
            allowed[k] = v
    return allowed


# -----------------------
# Mood / objective policy
# -----------------------
def update_mood(state: Dict[str, Any], turn: int) -> None:
    prog = state["progress"]
    style = state.get("last_agent_style", {})

    discovery_score = 0
    discovery_score += 1 if prog.get("agent_asked_dates") else 0
    discovery_score += 1 if prog.get("agent_asked_budget") else 0
    discovery_score += 1 if prog.get("agent_asked_pax") else 0
    discovery_score += 1 if prog.get("agent_asked_prefs") else 0
    discovery_score += 1 if prog.get("agent_asked_duration") else 0

    mood = state.get("mood", "neutral")

    if style.get("too_long", False) or (style.get("pushy", False) and not style.get("clear", True)):
        mood = "impatient"

    if turn >= 4 and discovery_score <= 1:
        mood = "impatient"
    elif turn >= 4 and discovery_score == 2 and mood != "impatient":
        mood = "neutral"

    state["mood"] = mood


def decide_objective(state: Dict[str, Any], turn: int) -> str:
    prog = state["progress"]
    max_turns = int(state.get("max_turns") or 7)
    last_sig = state.get("last_agent_sig") or {}

    if turn == 1:
        return "open_call_busy"

    # Multi-question detection WITHOUT overlap double-counting
    buckets = []
    if last_sig.get("asked_destination"):
        buckets.append("destination")
    if last_sig.get("asked_travellers"):
        buckets.append("travellers")
    if last_sig.get("asked_dates"):
        buckets.append("dates")
    if last_sig.get("asked_budget"):
        buckets.append("budget")
    if last_sig.get("asked_duration"):
        buckets.append("duration")
    if last_sig.get("asked_activities"):
        buckets.append("activities")
    elif last_sig.get("asked_soft_prefs"):
        buckets.append("soft_prefs")
    if last_sig.get("asked_preferences") and (not last_sig.get("asked_soft_prefs")):
        buckets.append("preferences")

    if len(set(buckets)) >= 2:
        return "answer_multi"

    if last_sig.get("asked_destination"):
        return "answer_destination"
    if last_sig.get("asked_travellers"):
        return "answer_travellers"
    if last_sig.get("asked_dates"):
        return "answer_dates"
    if last_sig.get("asked_budget"):
        return "answer_budget"
    if last_sig.get("asked_duration"):
        return "answer_duration"
    if last_sig.get("asked_activities"):
        return "answer_activities"
    if last_sig.get("asked_soft_prefs"):
        return "answer_soft_prefs"
    if last_sig.get("asked_preferences"):
        return "answer_preferences"

    busy_cooldown = int(state.get("busy_cooldown", 0))
    style = state.get("last_agent_style", {})
    if turn >= 3 and busy_cooldown <= 0 and (style.get("too_long", False) or (not style.get("clear", True))):
        return "busy_boundary"

    if turn >= 4 and not prog.get("agent_gave_price_estimate", False):
        return "ask_for_estimate"

    if prog.get("agent_gave_price_estimate", False) and not state.get("price_objection_used", False):
        return "raise_price_objection"

    if (prog.get("agent_proposed_next_step", False) and not state.get("trust_objection_used", False)) or (
        turn >= max_turns - 1 and not state.get("trust_objection_used", False)
    ):
        return "raise_trust_objection"

    if turn >= max_turns:
        return "close_call"

    if not last_sig.get("has_question_mark", False):
        return "no_question_nudge"

    return "continue"


# -----------------------
# Scripted + rule-based client replies
# -----------------------
def scripted_client_reply(
    state: Dict[str, Any],
    objective: str,
    last_sig: Dict[str, Any],
    scenario: Dict[str, Any],
) -> Optional[str]:
    slots = state.get("slots", {}) or {}
    travellers = slots.get("travellers") or "two adults"
    month = slots.get("month") or "next month"
    budget = slots.get("budget") or "a mid-range budget"
    duration = slots.get("duration") or "about a week"

    priority = slots.get("priority")
    pace = slots.get("pace")
    departure_city = slots.get("departure_city")

    beats = (scenario or {}).get("beats", {}) or {}
    prefs = get_soft_prefs(state)

    if objective == "open_call_busy":
        return "Hi—I'm planning a trip. What details do you need from me?"
    if objective == "busy_boundary":
        return "Sorry, can we keep it brief—what dates and budget do you need from me?"
    if objective == "answer_destination":
        return "No fixed destination yet—open to your suggestions."
    if objective == "answer_travellers":
        return f"It’s {travellers}."
    if objective == "answer_dates":
        return f"We’re thinking {month}."
    if objective == "answer_budget":
        return f"Our budget is {budget}."
    if objective == "answer_duration":
        return f"We’re thinking {duration}."
    if objective == "answer_preferences":
        if priority and pace and departure_city:
            return f"We want something {priority} and {pace}, leaving from {departure_city}."
        return "Prefer something comfortable and not too hectic."

    if objective == "answer_activities":
        if prefs.get("activities"):
            a = ", ".join(prefs["activities"][:2])
            return f"Mostly {a}—nothing too extreme."
        return None  # let Gemini answer + we remember

    if objective == "answer_soft_prefs":
        # If remembered, answer. Else let Gemini answer + remember.
        if prefs.get("hotel_style") or prefs.get("food"):
            bits = []
            if prefs.get("hotel_style"):
                bits.append(f"Hotel-wise, {prefs['hotel_style']}.")
            if prefs.get("food"):
                bits.append(f"Food-wise, {prefs['food']}.")
            return " ".join(bits)[:220]
        return None

    if objective == "answer_multi":
        parts: List[str] = []
        if last_sig.get("asked_destination"):
            parts.append("No fixed destination yet—open to your suggestions.")
        if last_sig.get("asked_travellers"):
            parts.append(f"It’s {travellers}.")
        if last_sig.get("asked_dates"):
            parts.append(f"We’re thinking {month}.")
        if last_sig.get("asked_budget"):
            parts.append(f"Our budget is {budget}.")
        if last_sig.get("asked_duration"):
            parts.append(f"Around {duration}.")
        if last_sig.get("asked_activities"):
            if prefs.get("activities"):
                a = ", ".join(prefs["activities"][:2])
                parts.append(f"Activities-wise, {a}.")
            else:
                return None
        if last_sig.get("asked_soft_prefs") and (not last_sig.get("asked_activities")):
            if prefs.get("hotel_style") or prefs.get("food"):
                if prefs.get("hotel_style"):
                    parts.append(f"Hotel-wise, {prefs['hotel_style']}.")
                if prefs.get("food"):
                    parts.append(f"Food-wise, {prefs['food']}.")
            else:
                return None
        if last_sig.get("asked_preferences") and (not last_sig.get("asked_soft_prefs")):
            if priority and pace and departure_city:
                parts.append(f"Prefer {priority} and {pace}, leaving from {departure_city}.")
            else:
                parts.append("Prefer something comfortable and not too hectic.")

        out = " ".join(parts)
        sents = re.split(r"(?<=[.!?])\s+", out)
        sents = [s.strip() for s in sents if s.strip()]
        return " ".join(sents[:2]).strip()

    if objective == "no_question_nudge":
        return "Okay—can you share 2–3 options and what the rough plan would look like?"
    if objective == "ask_for_estimate":
        return "Can you share a rough estimate range for this trip?"
    if objective == "raise_price_objection":
        return beats.get("price_objection") or "I saw cheaper online—what extra value do I get booking with you?"
    if objective == "raise_trust_objection":
        return beats.get("trust_objection") or "If something goes wrong, what support and cancellation policy do you provide?"
    if objective == "close_call":
        return "Okay—what’s the next step from your side?"

    return None


# -----------------------
# LLM fallback (Gemini)
# -----------------------
def llm_generate_client_reply(
    state: Dict[str, Any],
    history: List[Dict[str, str]],
    objective: str,
    scenario: Optional[Dict[str, Any]] = None,
) -> str:
    scenario = scenario or {}
    prog = state["progress"]
    beats = scenario.get("beats", {}) or {}
    busy_allowed = objective in {"open_call_busy", "busy_boundary"}

    last_sig = state.get("last_agent_sig") or {}
    scripted = scripted_client_reply(state, objective, last_sig, scenario)
    if scripted:
        out = finalize_client_text(state, scripted, busy_allowed=busy_allowed)
        return out

    mood = state.get("mood", "neutral")
    persona = scenario.get("persona", "Customer planning a trip")
    tone = scenario.get("tone", "friendly")

    allowed = allowed_facts_for_prompt(state)
    estimate_text = prog.get("agent_price_estimate_text") or ""
    prefs = get_soft_prefs(state)

    convo = []
    for turn in history[-10:]:
        who = "CLIENT" if turn["speaker"] == "client" else "AGENT"
        convo.append(f"{who}: {turn['text']}")
    convo_text = "\n".join(convo)

    prompt = f"""
You are a CUSTOMER on a phone call with a travel agent in India. You are NOT the agent.

Persona: {persona}
Baseline tone: {tone}
Current mood: {mood}

Hard rules:
- Output ONLY what you would say out loud. No brackets, no stage directions, no meta.
- Max 2 short sentences.
- If the agent asked multiple clear questions, answer them in one reply.
- Only use ALLOWED_FACTS for hard facts (travellers, month, budget, duration, departure). Do NOT invent or change those.
- You MAY answer soft preferences (activities/vibe/hotel style/food) ONLY if the agent asks about them.
- Do not recommend specific destinations/hotels; ask the agent for suggestions.
- Never say: I can help, I can assist, I recommend, we have options, I can book.

OBJECTIVE: {objective}

ALLOWED_FACTS JSON:
{json.dumps(allowed, ensure_ascii=False)}

KNOWN_PREFERENCES JSON:
{json.dumps(prefs, ensure_ascii=False)}

Scenario hints (attitude only):
price_objection_hint: {beats.get("price_objection")}
trust_objection_hint: {beats.get("trust_objection")}
agent_estimate_optional: {estimate_text}

Conversation so far:
{convo_text}

Now reply as the CUSTOMER:
""".strip()

    raw = gemini_generate_text(
        prompt=prompt,
        model=GEMINI_CLIENT_MODEL,
        temperature=0.55,
        max_output_tokens=120,
    )

    out = finalize_client_text(state, raw, busy_allowed=busy_allowed)

    # Remember soft prefs when it makes sense
    if objective in {"answer_activities", "answer_soft_prefs", "answer_multi", "continue"}:
        try:
            existing = get_soft_prefs(state)
            updated = extract_soft_prefs(state.get("last_agent_text", ""), out, existing)
            state["memory"]["soft_prefs"] = updated
        except Exception:
            pass

    out = avoid_repeat(state, out, objective=objective)
    return out


# -----------------------
# Scenario engine
# -----------------------
def scenario_next(session: Dict[str, Any], salesperson_text: Optional[str]) -> Tuple[str, bool]:
    state = session["state"]
    scenario = session.get("scenario") or {}

    state["_transcript_ref"] = session.get("transcript", [])

    if state.get("busy_cooldown", 0) > 0:
        state["busy_cooldown"] = int(state["busy_cooldown"]) - 1

    if salesperson_text is not None:
        salesperson_text = (salesperson_text or "").strip()
        session["transcript"].append({"speaker": "salesperson", "text": salesperson_text})

        if ABUSE_RX.search(salesperson_text):
            session["turn"] += 1
            state["busy_cooldown"] = 2
            reply = "Let’s keep it professional—can you tell me the dates and budget for the trip?"
            return finalize_client_text(state, reply, busy_allowed=True), False

        sig = detect_agent_signals(salesperson_text)
        state["last_agent_sig"] = sig
        state["last_agent_text"] = salesperson_text

        on_topic = (
            bool(TRAVEL_HINT.search(salesperson_text))
            or sig["asked_destination"]
            or sig["asked_budget"]
            or sig["asked_dates"]
            or sig["asked_travellers"]
            or sig["asked_duration"]
            or sig["asked_activities"]
            or sig["asked_soft_prefs"]
            or sig["asked_preferences"]
            or sig["proposed_next_step"]
            or sig["mentioned_inclusions"]
            or sig["gave_price_estimate"]
        )

        if not on_topic:
            session["turn"] += 1
            state["busy_cooldown"] = 2
            reply = "Can we stick to the trip—what dates and budget are you thinking?"
            return finalize_client_text(state, reply, busy_allowed=True), False

        prog = state["progress"]
        state["last_agent_style"] = heuristic_agent_style(salesperson_text)

        prog["agent_asked_budget"] |= sig["asked_budget"]
        prog["agent_asked_dates"] |= sig["asked_dates"]
        prog["agent_asked_pax"] |= sig["asked_travellers"]
        prog["agent_asked_prefs"] |= (sig["asked_preferences"] or sig["asked_soft_prefs"] or sig["asked_activities"])
        prog["agent_asked_duration"] |= sig["asked_duration"]
        prog["agent_proposed_next_step"] |= sig["proposed_next_step"]
        prog["agent_mentioned_inclusions"] |= sig["mentioned_inclusions"]

        disclose_if_asked(state, sig)

        prog["agent_gave_price_estimate"] |= sig["gave_price_estimate"]
        if sig["gave_price_estimate"] and not prog.get("agent_price_estimate_text"):
            prog["agent_price_estimate_text"] = salesperson_text.strip()

    session["turn"] += 1
    turn = session["turn"]

    update_mood(state, turn)
    objective = decide_objective(state, turn)

    if objective in {"open_call_busy", "busy_boundary"}:
        state["busy_cooldown"] = 2
    if objective == "raise_price_objection":
        state["price_objection_used"] = True
    if objective == "raise_trust_objection":
        state["trust_objection_used"] = True

    done = objective == "close_call"
    reply = llm_generate_client_reply(state, session["transcript"], objective, scenario=scenario)
    return reply, done


# -----------------------
# Scoring engine
# -----------------------
def score_call(transcript: List[Dict[str, str]]) -> Dict[str, Any]:
    sales_lines = [x["text"] for x in transcript if x["speaker"] == "salesperson"]
    sales_text = " ".join(sales_lines)

    sales_words = len(sales_text.split())
    client_words = len(" ".join(x["text"] for x in transcript if x["speaker"] == "client").split())
    total_words = max(1, sales_words + client_words)

    questions = sum(1 for line in sales_lines if "?" in line)
    open_questions = sum(1 for line in sales_lines if OPEN_Q.search(line))
    talk_ratio = round((sales_words / total_words) * 100, 1)

    asked_budget = bool(re.search(r"\bbudget|\bprice|\brange|\bspend", sales_text, re.I))
    asked_dates = bool(re.search(r"\bdate|\bwhen|\btravel dates|\bduration|\bnights|\bmonth|\bdays\b", sales_text, re.I))
    asked_pax = bool(re.search(r"\bpeople|\btravell?ers|\btravelers|\bhow many|\bpersons|\bkids|\badults", sales_text, re.I))
    asked_preferences = bool(re.search(r"\bpreference|\bhotel|\bflight|\bmeal|\bactivity|\bcomfort|\bpace", sales_text, re.I))

    gave_estimate = bool(PRICE_MENTION.search(sales_text))
    handled_objection = bool(re.search(r"\bcheaper|\bprice match|\bvalue|\bbenefit|\bcompare|\bworth\b", sales_text, re.I))
    closed_next_step = bool(re.search(r"\bbook|\bpay|\bpayment|\bquote|\bproposal|\bwhatsapp|\bemail|\bfollow up|\bcall you", sales_text, re.I))

    rubric = [
        ("Discovery & qualification", 20, [
            ("Asked budget", asked_budget),
            ("Asked dates/duration", asked_dates),
            ("Asked # travelers", asked_pax),
            ("Asked preferences/constraints", asked_preferences),
        ]),
        ("Value framing", 15, [
            ("Explained why option fits", bool(re.search(r"\bbecause|\bso that|\bfit|\bmatch|\bsuitable", sales_text, re.I))),
        ]),
        ("Objection handling", 15, [
            ("Handled price objection after quoting", (handled_objection if gave_estimate else True)),
        ]),
        ("Communication clarity", 10, [
            ("Used questions to guide", questions >= 2),
            ("Not overly dominant talk ratio", talk_ratio <= 75),
        ]),
        ("Closing & next steps", 15, [
            ("Proposed concrete next step", closed_next_step),
        ]),
        ("Accuracy & transparency", 10, [
            ("Mentioned inclusions/exclusions or policy", bool(re.search(r"\bincluded|\bexclude|\bcancellation|\brefund|\bterms|\bpolicy", sales_text, re.I))),
        ]),
        ("Rapport & empathy", 10, [
            ("Acknowledged needs/concerns", bool(re.search(r"\bi understand|\bmake sense|\bno worries|\bgot it|\bimportant to you", sales_text, re.I))),
        ]),
        ("Call control", 5, [
            ("Summarized or structured", bool(re.search(r"\bsummary|\brecap|\bto confirm|\bso far", sales_text, re.I))),
        ]),
    ]

    def cat_score_to_5(checks: List[Tuple[str, bool]]) -> int:
        hits = sum(1 for _, ok in checks if ok)
        if not checks:
            return 3
        ratio = hits / len(checks)
        if ratio >= 0.9:
            return 5
        if ratio >= 0.7:
            return 4
        if ratio >= 0.5:
            return 3
        if ratio >= 0.3:
            return 2
        if ratio > 0.0:
            return 1
        return 0

    categories = []
    total_points = 0.0
    for name, weight, checks in rubric:
        s5 = cat_score_to_5(checks)
        pts = round((s5 / 5.0) * weight, 1)
        total_points += pts
        categories.append({
            "name": name,
            "score_5": s5,
            "weight": weight,
            "points": pts,
            "checks": [{"item": item, "met": ok} for item, ok in checks],
        })

    overall = int(round(total_points))

    evidence = []
    for line in sales_lines:
        if "?" in line or re.search(r"\bbudget|\bdates|\bbook|\bquote|\binclude|\bcancel|₹|\blakh|\bstarting", line, re.I):
            evidence.append(line)
        if len(evidence) >= 3:
            break

    improvements = []
    if not asked_budget:
        improvements.append("Ask for a numeric budget range early (e.g., “What budget range are you comfortable with per person?”).")
    if not asked_dates:
        improvements.append("Confirm exact dates and flexibility (e.g., “Which week works?”).")
    if not gave_estimate:
        improvements.append("Offer a rough ballpark estimate once you have basics (a range builds trust).")
    if not closed_next_step:
        improvements.append("End with a clear next step + time (e.g., “I’ll send 2 options on WhatsApp in 10 minutes—can I call you at 6pm?”).")
    if talk_ratio > 80:
        improvements.append("Reduce monologue—ask more questions and pause for answers.")

    strengths = []
    if open_questions >= 2:
        strengths.append("Good use of open-ended questions.")
    if gave_estimate:
        strengths.append("You gave a rough estimate, which helps the customer decide.")
    if closed_next_step:
        strengths.append("You attempted a close / next step.")

    return {
        "overall_score": overall,
        "metrics": {
            "salesperson_word_share_percent": talk_ratio,
            "question_count": questions,
            "open_question_count": open_questions,
            "gave_price_estimate": gave_estimate,
        },
        "categories": categories,
        "evidence": evidence,
        "strengths": strengths[:3],
        "improvements": improvements[:4],
    }


# -----------------------
# STT repair (Gemini, different model)
# -----------------------
USE_STT_REPAIR = True
STT_REPAIR_MIN_CHARS = 8

_STOPWORDS = {
    "a","an","the","and","or","but","so","to","of","in","on","for","with","at","from","as",
    "is","am","are","was","were","be","been","being",
    "i","you","we","they","he","she","it","my","your","our","their",
    "this","that","these","those",
    "what","when","where","which","who","how","why",
    "please","plz","kindly","just","okay","ok","yeah","yep","no","yes",
    "do","did","does","can","could","would","should","will",
    "me","us","them","him","her",
}

def _tok_words(s: str) -> List[str]:
    return re.findall(r"[a-zA-Z']+", (s or "").lower())

def accept_repair(raw: str, clean: str) -> Tuple[bool, str]:
    raw = (raw or "").strip()
    clean = (clean or "").strip()
    if not raw or not clean:
        return False, "empty"

    r = _tok_words(raw)
    c = _tok_words(clean)
    if not c:
        return False, "no_tokens"

    raw_set = set(r)
    clean_set = set(c)

    raw_content = {w for w in raw_set if w not in _STOPWORDS}
    clean_content = {w for w in clean_set if w not in _STOPWORDS}

    new_content = clean_content - raw_content
    if new_content:
        return False, f"introduced_new_words:{sorted(list(new_content))[:6]}"

    overlap = sum(1 for w in c if w in raw_set)
    overlap_ratio = overlap / max(1, len(c))
    if overlap_ratio < 0.75:
        return False, f"low_overlap:{overlap_ratio:.2f}"

    if len(clean) > max(140, len(raw) * 2):
        return False, "too_long"

    return True, "ok"

def repair_stt_with_llm(raw: str) -> Dict[str, Any]:
    raw = (raw or "").strip()
    if not raw:
        return {"clean": "", "can_repair": False, "reason": "empty"}

    prompt = f"""
Return ONLY strict JSON:
{{"clean": string, "can_repair": boolean, "reason": string}}

Task: Convert messy speech-to-text into a clean single utterance said by a travel agent.

Rules:
- Keep SAME meaning. Do NOT add new facts/prices/destinations/dates/policies.
- Remove repetition/fillers, fix grammar, natural spoken English (India).
- clean: 1 sentence or 2 short sentences, max ~160 chars.

RAW_STT:
{raw}
""".strip()

    out = gemini_generate_text(
        prompt=prompt,
        model=GEMINI_REPAIR_MODEL,
        temperature=0.2,
        max_output_tokens=220,
    )

    data = _safe_json(out)
    clean = (data.get("clean") or "").strip()
    can_repair = bool(data.get("can_repair", True))
    reason = (data.get("reason") or "").strip()

    if not clean:
        return {"clean": raw, "can_repair": False, "reason": reason or "no_clean_text"}

    clean = re.sub(r"\s+", " ", clean).strip()
    if len(clean) > max(200, len(raw) * 3):
        return {"clean": raw, "can_repair": False, "reason": "too_long_after_repair"}

    return {"clean": clean, "can_repair": can_repair, "reason": reason or "ok"}


@app.post("/api/repair_stt")
async def api_repair_stt(payload: Dict[str, Any]):
    raw = (payload.get("text") or "").strip()
    repaired = repair_stt_with_llm(raw)
    clean = (repaired.get("clean") or "").strip()
    ok, why = accept_repair(raw, clean) if clean else (False, "no_clean")
    sig = detect_agent_signals(clean if ok else raw)
    return {
        "raw": raw,
        "clean": clean,
        "can_repair": repaired.get("can_repair", False),
        "reason": repaired.get("reason", ""),
        "accepted": ok,
        "accept_reason": why,
        "signals": sig,
    }


# -----------------------
# Pages + API
# -----------------------
@app.get("/", response_class=HTMLResponse)
async def index(request: Request):
    session_id = str(uuid.uuid4())

    scenario_id = random.choice(list(SCENARIOS.keys()))
    scenario = SCENARIOS[scenario_id]

    slots = dict(scenario["hidden_slots"])
    slots.setdefault("dates", None)
    slots.setdefault("destination", None)
    slots.setdefault("hotel_pref", None)

    disclosed = {k: False for k in slots.keys()}

    state = {
        "max_turns": scenario.get("max_turns", 7),
        "slots": slots,
        "disclosed": disclosed,
        "progress": {
            "agent_asked_budget": False,
            "agent_asked_dates": False,
            "agent_asked_pax": False,
            "agent_asked_prefs": False,
            "agent_asked_duration": False,
            "agent_proposed_next_step": False,
            "agent_mentioned_inclusions": False,
            "agent_gave_price_estimate": False,
            "agent_price_estimate_text": None,
        },
        "last_agent_style": {},
        "last_agent_sig": {},
        "last_agent_text": "",
        "mood": "neutral",
        "price_objection_used": False,
        "trust_objection_used": False,
        "busy_cooldown": 0,
        "memory": {
            "soft_prefs": {"theme": None, "activities": [], "hotel_style": None, "vibe": None, "food": None, "notes": []}
        },
    }

    SESSIONS[session_id] = {
        "turn": 0,
        "transcript": [],
        "done": False,
        "report": None,
        "scenario_id": scenario_id,
        "scenario": scenario,
        "state": state,
    }

    return templates.TemplateResponse("index.html", {"request": request, "session_id": session_id})


@app.get("/health")
async def health():
    ok_gemini = True
    err = ""
    try:
        _ = gemini_generate_text("Reply with OK.", model=GEMINI_REPAIR_MODEL, temperature=0.0, max_output_tokens=8)
    except Exception as e:
        ok_gemini = False
        err = str(e)

    return {
        "ok": True,
        "gemini": ok_gemini,
        "client_model": GEMINI_CLIENT_MODEL,
        "repair_model": GEMINI_REPAIR_MODEL,
        "gemini_error": err,
    }


@app.post("/api/start")
async def api_start(payload: Dict[str, Any]):
    session_id = payload["session_id"]
    session = SESSIONS.get(session_id)
    if not session:
        return JSONResponse({"error": "Invalid session"}, status_code=400)

    client_line, done = scenario_next(session, None)
    session["transcript"].append({"speaker": "client", "text": client_line})
    session["done"] = done
    return {"client_text": client_line, "done": done}


@app.post("/api/turn")
async def api_turn(payload: Dict[str, Any]):
    session_id = payload["session_id"]
    user_text_raw = (payload.get("user_text") or "").strip()

    session = SESSIONS.get(session_id)
    if not session:
        return JSONResponse({"error": "Invalid session"}, status_code=400)

    if session.get("done"):
        return {
            "client_text": "Session already ended.",
            "done": True,
            "user_text_raw": user_text_raw,
            "user_text_clean": user_text_raw,
            "stt_repaired": False,
            "stt_reason": "done",
        }

    user_text_clean = user_text_raw
    stt_repaired = False
    stt_reason = ""

    if USE_STT_REPAIR and len(user_text_raw) >= STT_REPAIR_MIN_CHARS:
        try:
            repaired = repair_stt_with_llm(user_text_raw)
            candidate = (repaired.get("clean") or "").strip()
            if repaired.get("can_repair", False) and candidate:
                ok, why = accept_repair(user_text_raw, candidate)
                if ok:
                    user_text_clean = candidate
                    stt_repaired = (user_text_clean != user_text_raw)
                    stt_reason = repaired.get("reason", "") or why
                else:
                    stt_reason = why
            else:
                stt_reason = repaired.get("reason", "cannot_repair")
        except Exception as e:
            stt_reason = f"repair_error: {e}"

    client_line, done = scenario_next(session, user_text_clean)
    session["transcript"].append({"speaker": "client", "text": client_line})
    session["done"] = done

    return {
        "client_text": client_line,
        "done": done,
        "user_text_raw": user_text_raw,
        "user_text_clean": user_text_clean,
        "stt_repaired": stt_repaired,
        "stt_reason": stt_reason,
    }


@app.post("/api/end")
async def api_end(payload: Dict[str, Any]):
    session_id = payload["session_id"]
    session = SESSIONS.get(session_id)
    if not session:
        return JSONResponse({"error": "Invalid session"}, status_code=400)

    report = score_call(session["transcript"])
    session["report"] = report
    return {"ok": True, "report_url": f"/report/{session_id}"}


@app.get("/report/{session_id}", response_class=HTMLResponse)
async def report_page(request: Request, session_id: str):
    session = SESSIONS.get(session_id)
    if not session or not session.get("report"):
        return HTMLResponse("No report yet. End the session first.", status_code=404)

    return templates.TemplateResponse(
        "report.html",
        {
            "request": request,
            "session_id": session_id,
            "report": session["report"],
            "transcript": session["transcript"],
        },
    )
